const initialState = {
  activeTab: "",
  tabs: {
    LandingPage: {
      componentsList: [],
      droppedComponents: [],
      activeDroppedComponentId: null,   // add active dropped component id here
    },
    ct1: {
      subtabs: {
        webForm1: {
          componentsList: [],
          droppedComponents: [],
        },
        webForm2: {
          componentsList: [],
          droppedComponents: [],
        }
      },
      activeDroppedComponentId: null,
    },
    Record: {
      componentsList: [],
      droppedComponents: [],
      activeDroppedComponentId: null,
    }
  }
};

const designSlice = createSlice({
  name: "design",
  initialState,
  reducers: {
    setActiveTab(state, action) {
      state.activeTab = action.payload;
    },

    addDroppedComponent(state, action) {
      // payload: { tabId, subTabId?, component }
      const { tabId, subTabId, component } = action.payload;

      if (subTabId) {
        state.tabs[tabId].subtabs[subTabId].droppedComponents.push(component);
      } else {
        state.tabs[tabId].droppedComponents.push(component);
      }

      // set active dropped component id at tab level (not subtab)
      state.tabs[tabId].activeDroppedComponentId = component.id;
    },

    updateDroppedComponent(state, action) {
      // payload: { tabId, subTabId?, componentId, updates }
      const { tabId, subTabId, componentId, updates } = action.payload;

      let droppedArray;
      if (subTabId) {
        droppedArray = state.tabs[tabId].subtabs[subTabId].droppedComponents;
      } else {
        droppedArray = state.tabs[tabId].droppedComponents;
      }

      const compIndex = droppedArray.findIndex((c) => c.id === componentId);
      if (compIndex !== -1) {
        droppedArray[compIndex] = { ...droppedArray[compIndex], ...updates };
      }
    },

    removeDroppedComponent(state, action) {
      // payload: { tabId, subTabId?, componentId }
      const { tabId, subTabId, componentId } = action.payload;

      let droppedArray;
      if (subTabId) {
        droppedArray = state.tabs[tabId].subtabs[subTabId].droppedComponents;
      } else {
        droppedArray = state.tabs[tabId].droppedComponents;
      }

      const index = droppedArray.findIndex((c) => c.id === componentId);
      if (index !== -1) {
        droppedArray.splice(index, 1);
      }

      // If removed component was active, clear activeDroppedComponentId
      if (state.tabs[tabId].activeDroppedComponentId === componentId) {
        state.tabs[tabId].activeDroppedComponentId = null;
      }
    },

    setActiveDroppedComponent(state, action) {
      // payload: { tabId, componentId }
      const { tabId, componentId } = action.payload;
      state.tabs[tabId].activeDroppedComponentId = componentId;
    },
  },
});

// Simulated Redux store
let state = {
  numbers: [1, 2, 3]
};

function reducer(action) {
  switch (action.type) {
    case 'ADD_NUMBER':
      // âŒ Mutating inside reducer (Immer in RTK would allow this, but here it's plain Redux)
      state.numbers.push(action.payload);
      return state;
    default:
      return state;
  }
}

function dispatch(action) {
  state = reducer(action);
}

function getState() {
  return state;
}

// --- Candidate's task starts here ---
// Selector (like useSelector)
const numbers = getState().numbers;

// Direct mutation without dispatch
numbers.push(4);

// Dispatch with another push
dispatch({ type: 'ADD_NUMBER', payload: 5 });

// Final array
const finalArray = getState().numbers;
console.log(finalArray);



const initialState = {
  items: [{ id: 1, name: 'Veda' }]
};

function reducer(state = initialState, action) {
  switch (action.type) {
    case 'COPY_AND_EDIT':
      const copy = state.items; // Looks like a copy, but it's a reference
      copy[0].name = 'Lead';
      return { ...state, items: copy };
    default:
      return state;
  }
}

let state = reducer(undefined, { type: 'COPY_AND_EDIT' });
console.log(state.items[0].name);


const [query, setQuery] = useState('');
useEffect(() => {
  const handler = setTimeout(() => fetchData(query), 500);
  return () => clearTimeout(handler);
}, [query]);


Write a search box that makes an API call only if the user stops typing for 500ms.





